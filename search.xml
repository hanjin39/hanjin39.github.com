<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[weex-Module 之 Native 和 JS 通信]]></title>
    <url>%2F2017%2F05%2F23%2Fweex-Module-communicate%2F</url>
    <content type="text"><![CDATA[自定义module扩展在前面文章已经介绍过，本文针对自定义module扩展时，列出了Native 和 JS 之间数据交互的几种方式。创建好了module后，剩下来就是传递数据了，数据传递分异步和同步两种方式。 JS给Native发送数据无需多说，通过调用module提供的方法时即可带上参数。本文而介绍的就是Native发送数据给JS时的几种方式了。 方法回调module定义方法时，即可提供回调给JS。回调类型有两种： WXModuleCallback 为了性能考虑，该回调只能回调通知js一次，之后会被释放，多用于一次结果。 123456789#import "WXEventModule.h"#import "WXDemoViewController.h"@implementation WXEventModuleWX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; //callback(@&#123;@"result":@"success",@"url":url&#125;); callback(@"success*****************");&#125; WXModuleKeepAliveCallback 该回调可以设置是否为多次回调类型，多次回调的场景如持续监听位置的变化，并返回给 js。 1234567@implementation WXEchoModule@synthesize weexInstance; // 让该module 获得当前instanceWX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);// 此处设置true，该回调function 可以多次回调执行，可以写循环测试.&#125; 事件通知在native发送事件并携带数据,JS监听事件拿到数据。 通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 实例级别的事件，即在当前实例（页面）有效，不能应用整个应用。 常用于定位信息，陀螺仪等的变化。 发送事件WXSDKInstance给我们提供了两种发送事件的方式。针对module和global的。 WXSDKInstance.h 123456789/** * fire module event; */- (void)fireModuleEvent:(Class)module eventName:(NSString *)eventName params:(NSDictionary*)params;/** * fire global event */- (void)fireGlobalEvent:(NSString *)eventName params:(NSDictionary *)params; 参数: eventName 事件名 params 参数 在iOS中，当前instance实例可以通过WXSDKEngine的加号方法获得: WXSDKEngine.h 12345/** * @abstract The Instance at the top of the rendering stack. * **/+ (WXSDKInstance *)topInstance; 例如：Android 123Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put("key","value");mWXSDKInstance.fireGlobalEventCallback("geolocation",params); iOS 1[weexInstance fireGlobalEvent:@"geolocation" params:@&#123;@"key":@"value"&#125;]; 如果是发送 module 事件: 12WXSDKInstance * instance = [WXSDKEngine topInstance];[instance fireModuleEvent:[WXPayModule class] eventName:@"moduleevent" params:@&#123;@"success":@"111"&#125;]; JS 注册事件 1addEventListener(String eventName, String callback) 参数: eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 例如: 1234var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener("geolocation", function (e) &#123; console.log("get geolocation")&#125;); 或者在自定义module上注册监听。 取消事件监听 1removeEventListener(String eventName) 例如: 12var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener("geolocation"); 同步方法同步拿到native数据，即不会用到回调函数。使用WX_EXPORT_METHOD_SYNC 宏。 iOS里面定义方法: 12345678@implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString)) - (NSString *)getString&#123; return @"testString";&#125;@end js 调用: 12const eventModule = weex.requireModule('event')const returnString = syncTest.getString() 至于采用哪种方式发送数据就得看实际场景了，能在module注册方法时直接回调当然好，很多时候是复杂的，比如实时更新位置等。 最近正在集成支付时用到事件通知，特此在这里总结一下，后续可能还会碰到新的需求再回来加上。]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>weex</tag>
        <tag>APP</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex之组件化开发]]></title>
    <url>%2F2017%2F05%2F21%2Fweex-commpoent%2F</url>
    <content type="text"><![CDATA[在我们日常开发中，将需要复用的功能或模块封装成模块既组件尤其重要，既方便又容易管理，小至一个按钮，大致整个功能模块，比如三级省市区选择，拍照上传等等，做好组件后，也方便后面的项目中的使用，也可以上传到插件市场，方便你我。 封装组件需要考虑父子组件之间的通信： 父组件传递数据给子组件。一般进行子组件的初始化，设置属性等。 子组件需要给父组件反馈，将处理数据返回给父组件。 父子附件见得解耦很重要，在 Vue.js 中，父子组件的关系总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。 咱们可以看下weex GitHub上面给我们提供的example的导航组件。 子组件 navpage.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;navbar :dataRole=&quot;dataRole&quot; :height=&quot;height&quot; :backgroundColor=&quot;backgroundColor&quot; :title=&quot;title&quot; :titleColor=&quot;titleColor&quot; :leftItemSrc=&quot;leftItemSrc&quot; :leftItemTitle=&quot;leftItemTitle&quot; :leftItemColor=&quot;leftItemColor&quot; :rightItemSrc=&quot;rightItemSrc&quot; :rightItemTitle=&quot;rightItemTitle&quot; :rightItemColor=&quot;rightItemColor&quot; @naviBarRightItemClick=&quot;naviBarRightItemClick&quot; @naviBarLeftItemClick=&quot;naviBarLeftItemClick&quot; &gt;&lt;/navbar&gt; &lt;div class=&quot;wrapper&quot; :style=&quot;&#123; marginTop: height &#125;&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; width: 750; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; components: &#123; navbar: require(&apos;./navbar.vue&apos;) &#125;, props: &#123; dataRole: &#123; default: &apos;navbar&apos; &#125;, backgroundColor: &#123; default: &apos;black&apos; &#125;, height: &#123; default: 88 &#125;, title: &#123; default: &quot;&quot; &#125;, titleColor: &#123; default: &apos;black&apos; &#125;, rightItemSrc: &#123; default: &apos;&apos; &#125;, rightItemTitle: &#123; default: &apos;&apos; &#125;, rightItemColor: &#123; default: &apos;black&apos; &#125;, leftItemSrc: &#123; default: &apos;&apos; &#125;, leftItemTitle: &#123; default: &apos;&apos; &#125;, leftItemColor: &#123; default: &apos;black&apos; &#125; &#125;, methods: &#123; naviBarRightItemClick: function (e) &#123; this.$emit(&apos;naviBarRightItemClick&apos;, e) &#125;, naviBarLeftItemClick: function (e) &#123; this.$emit(&apos;naviBarLeftItemClick&apos;, e) &#125; &#125; &#125;&lt;/script&gt; 使用Prop传递数据在vue中使用prop从父组件传递数据到子组件。在子组件里面设置props选项，可以用简单的数组，但推荐使用对象，对象允许配置类型检测，校验和设置默认值，方便其他人使用。 在子组件 12345678910111213141516171819 export default &#123; props: &#123; // 只检测类型 height: Number, // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;, data() &#123; return &#123; &#125; &#125;,&#125; 定义好props后就可用在父组件里面使用了。 比如在其他页面使用navpage.vue： 使用前在components里面引入组件 123components: &#123; navpage: require(&apos;../../navpage.vue&apos;),&#125; 在页面里使用组件,并传递初始属性。 123456789101112&lt;template&gt; &lt;div style=&quot;flex-direction: column;&quot;&gt; &lt;navpage dataRole=&quot;none&quot; :height=&quot;navBarHeight&quot; :title=&quot;title&quot; backgroundColor=&quot;#FF0000&quot; titleColor=&quot;white&quot; &gt; &lt;/navpage&gt; ... &lt;/div&gt;&lt;/template&gt; 触发事件子组件要把数据回传给父组件，那就是触发事件，父组件监听该事件，子组件就可以通过事件把数据传递过去。 vue实例实现了事件接口(Events interface)， 子组件使用 $emit(eventName) 触发事件。在navpage.vue里面，有两个点击事件:naviBarRightItemClick,naviBarLeftItemClick。在这两个事件方法里面触发新的事件(这里只是做了传递事件，没有传递数据): 12345678methods: &#123; naviBarRightItemClick: function (e) &#123; this.$emit(&apos;naviBarRightItemClick&apos;, e) &#125;, naviBarLeftItemClick: function (e) &#123; this.$emit(&apos;naviBarLeftItemClick&apos;, e) &#125; &#125; 使用 $on(eventName)在父组件里面监听事件 123456789101112131415 &lt;template&gt; &lt;div style=&quot;flex-direction: column;&quot;&gt; &lt;navpage dataRole=&quot;none&quot; :height=&quot;navBarHeight&quot; :title=&quot;title&quot; backgroundColor=&quot;#FF0000&quot; titleColor=&quot;white&quot; leftItemTitle=&quot;返回&quot; leftItemColor=&quot;white&quot; @naviBarLeftItemClick=&quot;back&quot; &gt; &lt;/navpage&gt; ... &lt;/div&gt;&lt;/template&gt; 12345 methods: &#123; back:function () &#123; //处理返回 &#125;,&#125; 页面监听了naviBarLeftItemClick事件,并定义了对应的处理方法。 传递参数看下$emit事件: 1vm.$emit( event, […args] ) {string} event：触发当前实例上的事件 […args] ：附加参数都会传给监听器回调。可以是多个参数或者一个对象。 比如我的一个组件里面需要传递当前点击的索引等，参数比较多的时候放在对象里面： 子组件 12345var params = &#123; index: currentIndex, ...&#125;;this.$emit(&apos;tabOnClick&apos;, params); 在父组件里面监听事件并解析参数: 父组件 123tabOnClick: function (params) &#123; console.log(params.index);&#125;, 在开发当中，尽量把一些需要复用的或者经常用到的功能做成组件，在日后的开发中也便于集中管理，也方便其他同事调用，节省时间。在开发完一个应用后，把一些常见的组件集中起来，比较好用的后面我也会分享出来，大家有一些通用的组件也可以告诉我 :）。]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>weex</tag>
        <tag>APP</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Weex Module 扩展]]></title>
    <url>%2F2017%2F05%2F15%2Fweex-Module%2F</url>
    <content type="text"><![CDATA[就像官网说的，Weex SDK 只提供渲染。很多东西必须native自己去实现，比如网络，图片(实现WXImgLoaderProtocol)，又比如上传图片，很多场景需要调出手机相册或者摄像头拍照，weex做不到，只能去native写扩展。先搞清楚怎么实现扩展后，然后再去实现功能就容易了。 在做实验之前假装你已经成功集成了WeexSDK到你的应用了。(集成 Weex 到已有应用) iOS自定义module的步骤 自定义 WXEventModule类,实现 WXModuleProtocol。 WXEventModule.h 1234#import &lt;Foundation/Foundation.h&gt;#import &lt;WeexSDK/WXModuleProtocol.h&gt;@interface WXEventModule : NSObject&lt;WXModuleProtocol&gt;@end 暴露方法给weex调用。在方法上面添加宏WX_EXPORT_METHOD,传递了一个SEL类型的对象。方法的参数也是weex调用的参数。 WXEventModule.m 12345678#import "WXEventModule.h"@implementation WXEventModuleWX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; //do something &#125; weex 传递的参数可以是String 或者Map，Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map。(在iOS中可以是string/number/array/dictionary) 12345678910#import "WXEventModule.h"#import "WXDemoViewController.h"@implementation WXEventModuleWX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; //callback(@&#123;@"result":@"success",@"url":url&#125;); callback(@"success*****************");&#125; 注册 module调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module。 1[WXSDKEngine registerModule:@"event" withClass:[WXEventModule class]]; 使用自己的 module在weex里面调用 registerModule: 注册 module 时候的 name，即event。 123456789101112&lt;template&gt;&lt;/template&gt;&lt;script&gt; var eventModule = weex.requireModule(&apos;event&apos;); export default &#123; created: function () &#123; eventModule.openURL(&apos;url&apos;,function(ret) &#123; nativeLog(ret); &#125;); &#125;, &#125;&lt;/script&gt; 实现功能实现了与weex的桥接了，现在就来看看实现具体的功能了。 问题：定义了方法之后，怎么调用咱们的实现？ 在负责渲染weex页面控制器里面定义实现，我这里是WXDemoViewController。定义了一个测试方法： WXDemoViewController.h 123//功能实现-(void)takepicture;@end WXDemoViewController.m 1234//功能实现-(void)takepicture&#123; NSLog(@"takepicture********************");&#125; 在WXEventModule里面要调用WXDemoViewController的takepicture方法，需要在WXEventModule里添加@synthesized weexInstance绑定到当前实例上。 12345678910111213#import "WXEventModule.h"#import "WXDemoViewController.h"@implementation WXEventModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; //callback(@&#123;@"result":@"success",@"url":url&#125;); callback(@"success*****************"); [(WXDemoViewController *)weexInstance.viewController takepicture];&#125;@end weexInstance.viewController即取到当前渲染的控制器，就可以调用该方法了。 123456789101112#import &lt;UIKit/UIKit.h&gt;#import "WXComponent.h"@class WXResourceRequest;extern NSString *const bundleUrlOptionKey;@interface WXSDKInstance : NSObject/** * The viewControler which the weex bundle is rendered in. **/@property (nonatomic, weak) UIViewController *viewController; AndroidAndroid里面实现扩展需要用到WXSDKEngine。 Module 扩展继承 WXModule 类. Module中的扩展方法必须是 public 类型 添加 @JSMethod(uiThread = false或true) 注释来选择 moudle 的回调模式. 需要用到JSCallback 通知给js回调。 12345678910111213@JSMethod public void getLocation(JSCallback callback)&#123; //获取定位代码..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put("x","x"); data.put("y","y"); //通知一次 callback.invoke(data); //持续通知 callback.invokeAndKeepAlive(data); //invoke方法和invokeAndKeepAlive两个方法二选一 &#125; 完成 Module,找到WXApplication后，在初始化WXSDKEngine注册 WXSDKEngine.registerModule(“myModule”, MyModule.class); 调用方法即可参考iOS。]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>weex</tag>
        <tag>APP</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成 Devtools]]></title>
    <url>%2F2017%2F05%2F15%2Fweex-Devtools%2F</url>
    <content type="text"><![CDATA[Weex 提供了Weex Devtools来调试页面，当直接调试单页面和扫码都不能满足我们的时候，或者一开始，我们就应该集成Devtools到我们的APP中去。 Devtools集成到客户端后，通过webscoket 连接到调试服务器，Devtools 服务器端是客户端和Chrome web端的桥梁，负责消息转发和运行时管理，整个调试过程就是这几个进程之间协同交换运行结果的过程，Devtools详细通信机制可以参考Devtools 组件介绍 一. 接入Devtools推荐添加cocoapods依赖来集成。在工程目录的 podfile 添加依赖： 12source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;] 之后运行’pod install’. 二. 注册功能在程序一启动就开启 Weex 调试(当然你也可以在别的地方),即在 WeexSDK 引擎初始化之前。比如你可以在AppDelegate.m里面： 1. 添加头文件1#import &lt;TBWXDevTool/WXDevTool.h&gt; 2. 开启调试。在- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions添加代码： 12[WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@"ws://192.168.0.104:8088/debugProxy/native"]; setDebug：参数为 YES 时，开启 debug 模式，反之关闭. 设置launchDevToolDebugWithUrl 的参数ws地址： 在本地开启Debug 服务:weex debug (开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对于定位问题非常有帮助，建议调试中默认开启 server 端 log。) 终端 其中的 ws 地址正是launchDevToolDebugWithUrl接口的参数。 3. 添加页面刷新功能当开启调试时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationRefreshInstance:) name:@"RefreshInstance" object:nil]; 在 dealloc 方法中取消通知 1234- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance 12[_instance destroyInstance];_instance = [[WXSDKInstance alloc] init]; 三. 使用 开启weex debug后Chrome是空白的： 运行xcode，如果集成成功你会看到： 并且模拟器会是空白的，不要着急。 点击Debugger，你会看到日志，模拟器也恢复正常了。 至此就算集成成功，你可以看到Chrome和xcode都有日志，还可以在js里面打断点，比如： 详细的调试功能参考使用 Devtools 调试 Weex 页面 集成 Devtools 到 Android添加依赖 通过 Gradle 添加对 devtools aar 的依赖. 123dependencies &#123; compile 'com.taobao.android:weex_inspector:0.8.0.0'&#125; 反射引用的包(0.8.0.0以上版本) 12345dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 添加 Debug 模式开关最简单的方式是通过在 XXXApplication 中设置开关打开调试模式。 123456public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, true, "192.168.0.104"); &#125;&#125; initDebugEnvironment方法: 1234567891011121314/** * @param enable enable remote debugger. valid only if host not to be "DEBUG_SERVER_HOST". * true, you can launch a remote debugger and inspector both. * false, you can just launch a inspector. * @param host the debug server host, must not be "DEBUG_SERVER_HOST", a ip address or domain will be OK. * for example "127.0.0.1". */ private void initDebugEnvironment(boolean connectable,boolean enable, String host) &#123; if (!"DEBUG_SERVER_HOST".equals(host)) &#123; WXEnvironment.sDebugServerConnectable = connectable; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = "ws://" + host + ":8088/debugProxy/native"; &#125; &#125; connectable 是否开启Debug enable 选择remote debugger模式。true，开启remote debugger 和 inspector。false只开启 inspector host本机的ip地址，同样可以参考上面如何获取ws地址。 使用步骤同iOS 开启Debug 服务后： 至此，Devtools集成完毕，have fun!]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>weex</tag>
        <tag>APP</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 初体验]]></title>
    <url>%2F2017%2F05%2F15%2Fweex-first-start%2F</url>
    <content type="text"><![CDATA[使用官方提供的脚手架weex-toolkit来创建weex项目，调试打包。最新的weex-toolkit 支持对 weexpack 的命令调用。我们可以轻松构建项目，创建iOS和Android应用工程和添加插件，快速打包应用并安装到手机上运行。 安装 安装 node.js,请确保node 版本是&gt;=6。 使用npm全局安装： 1$ npm install -g weex-toolkit 安装成功后，用weex -v查看当前版本: 123456$ weex -v v1.0.5 - weex-builder : v0.2.6 - weex-devtool : v0.2.80 - weex-previewer : v1.3.7 - weexpack : v0.4.0 安装过程可能很慢，可以使用淘宝的镜像： 123456$ npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功$ npm config get registry// 或$ npm info express 国内优秀npm镜像推荐及使用 切记不要用cnpm,cnpm装下来可能会少包和一些奇妙的问题。 初始化weex项目官方提供的 1$ weex init awesome-project 初始化的项目给刚接触的新手熟悉weex，构建的是单页应用。这里我要推荐的是weex提供的另一个命令构建项目： 1$ weex create awesome-project 其实是weex-toolkit 扩展了weexpack，weexpack能够通过命令创建weex工程，添加iOS或者Android和web平台的APP模板并构建移动端工程，省去了手动集成weexsdk的麻烦，还会安装一些默认的扩展model等，可以快速打包weex应用，还可以安装weex插件。 创建完项目后进入目录安装依赖npm install，之后运行 npm run dev 和 npm run serve 开启 watch 模式和静态服务器。 然后打开浏览器，进入 http://localhost:8080/index.html 即可看到 Weex h5 页面。 到这里就可以看到单个页面，但真正的项目可不是一个页面这么简单。 添加平台模板weex-toolkit 支持对 weexpack 的命令调用。所以我们可以参考weexpack 添加Android模板： 1$ weex platform add android ios模版 1$ weex platform add ios 安装模板后的目录是这样的: 环境配置Android推荐安装Android Studio。 安装SDK和 Android SDK Build-Tool。weexpack 指定了编译所需的版本：需要 Android 5.1版本的 SDK 以及 23.0.2 版本的 Android SDK Build-Tool。 配置环境变量 123456789# 打开环境变量配置文件vim ~/.bash_profile# 加入以下两行 export ANDROID_HOME=/xxx/Library/Android/sdk # 修改目录为 Preferences 中显示的目录（上图高亮部分）export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools#保存source ~/.bash_profile 运行之前打开模拟器 iOS如果系统中没有 CocoaPods，需要安装： 1$ sudo gem install cocoapods 打包应用并安装运行直接运行命令即可打开模拟器运行当前项目。 打包运行android应用 1$ weex run android 打包运行ios应用 1$ weex run ios 放2张项目的截图： 打包过程中需要下载依赖和编译工具，是个较为耗时的过程，安装运行之前需要打开模拟器或者连接设备。打包运行时可能很顺，也可能错误百出，仁者见仁智者见智。这里有一篇饿了么前端贡献的一篇入坑指南，希望会帮到你。]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>weex</tag>
        <tag>APP</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>